
            return ts.getObjectFlags(type) & 256 /* EvolvingArray */ ? type.elementType : neverType;
        }
        function isEvolvingArrayTypeList(types) {
            var hasEvolvingArrayType = false;
            for (var _i = 0, types_19 = types; _i < types_19.length; _i++) {
                var t = types_19[_i];
                if (!(t.flags & 131072 /* Never */)) {
                    if (!(ts.getObjectFlags(t) & 256 /* EvolvingArray */)) {
                        return false;
                    }
                    hasEvolvingArrayType = true;
                }
            }
            return hasEvolvingArrayType;
        }
        // Return true if the given node is 'x' in an 'x.length', x.push(value)', 'x.unshift(value)' or
        // 'x[n] = value' operation, where 'n' is an expression of type any, undefined, or a number-like type.
        function isEvolvingArrayOperationTarget(node) {
            var root = getReferenceRoot(node);
            var parent = root.parent;
            var isLengthPushOrUnshift = ts.isPropertyAccessExpression(parent) && (parent.name.escapedText === "length" ||
                parent.parent.kind === 204 /* CallExpression */
                    && ts.isIdentifier(parent.name)
                    && ts.isPushOrUnshiftIdentifier(parent.name));
            var isElementAssignment = parent.kind === 203 /* ElementAccessExpression */ &&
                parent.expression === root &&
                parent.parent.kind === 217 /* BinaryExpression */ &&
                parent.parent.operatorToken.kind === 62 /* EqualsToken */ &&
                parent.parent.left === parent &&
                !ts.isAssignmentTarget(parent.parent) &&
                isTypeAssignableToKind(getTypeOfExpression(parent.argumentExpression), 296 /* NumberLike */);
            return isLengthPushOrUnshift || isElementAssignment;
        }
        function isDeclarationWithExplicitTypeAnnotation(declaration) {
            return (declaration.kind === 250 /* VariableDeclaration */ || declaration.kind === 161 /* Parameter */ ||
                declaration.kind === 164 /* PropertyDeclaration */ || declaration.kind === 163 /* PropertySignature */) &&
                !!ts.getEffectiveTypeAnnotationNode(declaration);
        }
        function getExplicitTypeOfSymbol(symbol, diagnostic) {
            if (symbol.flags & (16 /* Function */ | 8192 /* Method */ | 32 /* Class */ | 512 /* ValueModule */)) {
                return getTypeOfSymbol(symbol);
            }
            if (symbol.flags & (3 /* Variable */ | 4 /* Property */)) {
                if (ts.getCheckFlags(symbol) & 262144 /* Mapped */) {
                    var origin = symbol.syntheticOrigin;
                    if (origin && getExplicitTypeOfSymbol(origin)) {
                        return getTypeOfSymbol(symbol);
                    }
                }
                var declaration = symbol.valueDeclaration;
                if (declaration) {
                    if (isDeclarationWithExplicitTypeAnnotation(declaration)) {
                        return getTypeOfSymbol(symbol);
                    }
                    if (ts.isVariableDeclaration(declaration) && declaration.parent.parent.kind === 240 /* ForOfStatement */) {
                        var statement = declaration.parent.parent;
                        var expressionType = getTypeOfDottedName(statement.expression, /*diagnostic*/ undefined);
                        if (expressionType) {
                            var use = statement.awaitModifier ? 15 /* ForAwaitOf */ : 13 /* ForOf */;
                            return checkIteratedTypeOrElementType(use, expressionType, undefinedType, /*errorNode*/ undefined);
                        }
                    }
                    if (diagnostic) {
                        ts.addRelatedInfo(diagnostic, ts.createDiagnosticForNode(declaration, ts.Diagnostics._0_needs_an_explicit_type_annotation, symbolToString(symbol)));
                    }
                }
            }
        }
        // We require the dotted function name in an assertion expression to be comprised of identifiers
        // that reference function, method, class or value module symbols; or variable, property or
        // parameter symbols with declarations that have explicit type annotations. Such references are
        // resolvable with no possibi